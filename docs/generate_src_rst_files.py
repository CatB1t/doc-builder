import os
import string
import shutil
import argparse

EXCLUDED_MODULES = ['exceptions', 'library_getter', 'setup', '__init__']
EXCLUDED_DIRS = ['.pytest_cache', 'docs', 'tests', '__pycache__']

SUBMODULE_TITLE = ''
ROOT_DIR = ''

with open('partial_source/supported_frameworks.rst') as fw_file:
    SUPPORTED_FRAMEWORKS = fw_file.read()


def remove_absolute_img_links(readme_contents):
    lines = readme_contents.split('\n')
    new_lines = list()
    for line in lines:
        new_line = line
        squashed_line = line.replace(' ', '')
        if len(squashed_line) >= 28 and squashed_line[0:28] == '..image::https://github.com/' and \
                'docs/partial_source' in squashed_line:
            pre, post = line.split('docs/partial_source')
            pre = pre.split('https')[0]
            new_line = 'docs/partial_source'.join([pre, post])
        new_lines.append(new_line)
    return '\n'.join(new_lines)


def create_index_rst(sub_contents_dict):
    prepend_filepath = 'partial_source/index_prepend.rst'
    with open(prepend_filepath) as file:
        prepend_data = file.read()

    with open('../README.rst') as file:
        readme_contents = file.read()
    readme_contents = readme_contents.replace('Check out the docs_ for more info!', '')
    readme_contents = readme_contents.replace('</div>\n    <br clear="all" />\n', '</div>\n    <br clear="all" />\n    <br/>\n    <br/>\n')
    readme_contents = remove_absolute_img_links(readme_contents)
    readme_contents = readme_contents.replace('docs/partial_source/', '../autogenerated_source/')
    readme_contents = readme_contents.replace('../autogenerated_source/logos/supported/', '_images/')
    readme_contents = readme_contents.replace('../autogenerated_source/logos/', '_images/')
    readme_contents = readme_contents.replace('../autogenerated_source/images/', '_images/')

    append_filepath = 'partial_source/index_append.rst'
    if os.path.exists(append_filepath):
        with open(append_filepath) as file:
            append_data = file.read()
    else:
        append_data = ''

    all_data = prepend_data + '\n' + readme_contents + '\n' + '\nDocumentation Tree\n------------------\n' + append_data

    with open('autogenerated_source/index.rst', 'w+') as file:
        file.write(all_data)

    # toctree dict
    toctree_dict = dict()
    for key, value in sub_contents_dict.items():
        new_key = key.split('/')[-1]
        new_value = [item.split('/')[-1].replace('.py', '') + '.rst' for item in value]
        toctree_dict[new_key] = new_value

    if SUBMODULE_TITLE is not None:
        # append toctree
        append_toctree_to_rst(toctree_dict, 'autogenerated_source/index.rst', SUBMODULE_TITLE)
        toctree_dict = dict()

    this_dir = os.path.dirname(os.path.realpath(__file__))
    with open(os.path.join(this_dir, 'ivy_modules.txt'), 'r') as f:
        module_names = [line.replace('\n', '') for line in f.readlines()]

    toctree_dict['docs'] = [mod_name + '.rst' for mod_name in module_names]
    os.makedirs('autogenerated_source/docs', exist_ok=True)
    for fname in toctree_dict['docs']:
        with open('autogenerated_source/docs/{}'.format(fname), 'w+') as file:
            title_str = fname[:-4].replace('_', ' ').capitalize()
            file.write(title_str + '\n' + '='*len(title_str))

    # append toctree
    append_toctree_to_rst(toctree_dict, 'autogenerated_source/index.rst')


def append_toctree_to_rst(toctree_dict, rst_path, caption=None):
    str_to_write = '\n'
    for key, list_of_rsts in toctree_dict.items():
        cap = key.capitalize().replace('_', ' ') if caption is None else caption
        str_to_write += '\n.. toctree::\n   :maxdepth: -1\n   :caption: ' + cap + '\n\n'
        for rst_filename in list_of_rsts:
            str_to_write += '   ' + os.path.join(key, rst_filename) + '\n'
        str_to_write += '\n'
    with open(rst_path, 'a') as file:
        file.write(str_to_write)


def copy_readme_to_rst(readme_path, rst_path):
    with open(readme_path) as file:
        readme_contents = file.read()
    with open(rst_path, 'w+') as file:
        file.write(readme_contents)


def get_functions_and_classes(module_path, dotted_namespace):
    with open(module_path, errors='replace') as file:
        module_str = file.read()
    all_function_names = [dotted_namespace + '.' + item.split('(')[0] for item in module_str.split('\ndef ')[1:]]
    public_function_names = [n for n in all_function_names if n.split('.')[-1][0] != '_']
    class_names = [dotted_namespace + '.' + item.split('(')[0] for item in module_str.split('\nclass ')[1:]]
    return public_function_names, class_names


def create_rst_files(directory):
    # get contents of directory
    contents = os.listdir(directory)
    contents.sort()

    # represent as file-paths
    cont_paths = [os.path.join(directory, item) for item in contents]

    # save dir in docs
    repo_name = ROOT_DIR.split('/')[-1]
    repo_location = directory.find(repo_name)
    name_len_p1 = len(repo_name) + 1
    doc_save_dir = os.path.join('autogenerated_source', directory[repo_location + name_len_p1:])
    os.makedirs(os.path.dirname(doc_save_dir), exist_ok=True)

    # extract sub-dirs
    sub_dirs = [item for item in cont_paths if os.path.isdir(item) and item.split('/')[-1] not in EXCLUDED_DIRS]

    # sub-modules container
    sub_contents = dict()

    # perform this function on them recursively.
    for sub_dir in sub_dirs:
        sub_sub_dirs, sub_modules = create_rst_files(sub_dir)
        sub_contents[sub_dir] = sub_sub_dirs + sub_modules

    # extract python modules
    modules = [item for item in cont_paths if item[-3:] == '.py' and item.split('/')[-1][:-3] not in EXCLUDED_MODULES]

    # get classes and functions for these modules
    for module in modules:

        # create directory structure for this module
        new_filepath = os.path.join('autogenerated_source', module[repo_location + name_len_p1:])[:-2] + 'rst'
        new_module_dir = os.path.join('autogenerated_source', module[repo_location + name_len_p1:])[:-3]
        os.makedirs(new_module_dir, exist_ok=True)

        # dotted namespace
        dotted_namespace = module[repo_location:-3].replace('/', '.')

        # title
        module_name = module.split('/')[-1][:-3]
        module_title = module_name.replace('_', ' ')

        with open(new_filepath, 'w+') as file:
            file.write(module_title.capitalize() + '\n' +
                       '=' * len(module_title) + '\n\n'
                                                 '.. automodule:: ' + dotted_namespace + '\n'
                                                                                         '    :members:\n'
                                                                                         '    :special-members: __init__\n'
                                                                                         '    :undoc-members:\n'
                                                                                         '    :show-inheritance:\n'
                       )

        # get function and class names
        functions, classes = get_functions_and_classes(module, dotted_namespace)

        # function names
        function_names = [item.split('.')[-1] for item in functions]

        # class names
        class_names = [item.split('.')[-1] for item in classes]

        # add toctree for functions in module
        toctree_dict = {module_name: [func_name + '.rst' for func_name in function_names] +
                                     [class_name + '.rst' for class_name in class_names]}
        append_toctree_to_rst(toctree_dict, new_filepath)

        # supported_frameworks
        supported_fw_str = SUPPORTED_FRAMEWORKS.replace('logos', '../' * directory.count('/') + 'logos')

        # write function rst files
        for func_name, dotted_func in zip(function_names, functions):
            function_filepath = os.path.join(new_module_dir, func_name) + '.rst'
            with open(function_filepath, 'w+') as file:
                file.write(func_name + '\n' +
                           '=' * len(func_name) + '\n\n'
                                                  '.. autofunction:: ' + dotted_func + '\n' +
                           supported_fw_str)

        # write class rst files
        for class_name, dotted_class in zip(class_names, classes):
            class_filepath = os.path.join(new_module_dir, class_name) + '.rst'
            with open(class_filepath, 'w+') as file:
                file.write(class_name + '\n' +
                           '=' * len(class_name) + '\n\n'
                                                  '.. autoclass:: ' + dotted_class + '\n' +
                                                  '   :members:\n' +
                                                  '   :special-members: __init__\n' +
                                                  '   :undoc-members:\n' +
                                                  '   :show-inheritance:\n' +
                           supported_fw_str)

    if 'README.rst' in contents:
        # copy README to docs
        doc_save_dir_split = doc_save_dir.split('/')
        readme_save_dir = '/'.join(doc_save_dir_split[:-1])
        module_name = doc_save_dir_split[-1]
        rst_filename = module_name + '.rst'
        readme_path = os.path.join(directory, 'README.rst')
        rst_path = os.path.join(readme_save_dir, rst_filename)
        copy_readme_to_rst(readme_path, rst_path)

        # append toctree
        toctree_key = module_name
        toctree_key_values = [item.split('/')[-1] + '.rst' for item in sub_dirs] + \
                             [item.split('/')[-1][:-3] + '.rst' for item in modules]
        toctree_dict = {toctree_key: toctree_key_values}
        append_toctree_to_rst(toctree_dict, rst_path)

    if directory == ROOT_DIR:
        if SUBMODULE_TITLE is not None:
            create_index_rst({'': modules})
        else:
            create_index_rst(sub_contents)

    return sub_dirs, modules


def main(root_dir, submodules_title):
    global ROOT_DIR
    ROOT_DIR = root_dir
    global SUBMODULE_TITLE
    SUBMODULE_TITLE = submodules_title
    project_title = string.capwords(root_dir.split('/')[-1].replace('_', ' '))
    with open('partial_source/conf.py', 'r') as conf_file:
        conf_contents = conf_file.read()
        conf_contents = conf_contents.replace("project = 'Ivy'", "project = '{}'".format(project_title))
    with open('partial_source/conf.py', 'w') as conf_file:
        conf_file.write(conf_contents)
    if os.path.exists('autogenerated_source'):
        shutil.rmtree('autogenerated_source')
    shutil.copytree('partial_source/images', 'build/_images')
    shutil.copyfile('partial_source/logos/logo.png', 'build/_images/logo.png')
    shutil.copytree('partial_source', 'autogenerated_source')
    create_rst_files(root_dir)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--root_dir', type=str, required=True,
                        help='Root directory of the repository relaitve to current directory.')
    parser.add_argument('--submodules_title', type=str,
                        help='The title for the combination of submodules.'
                             'Only valid when there are no submodule directories.')
    parsed_args = parser.parse_args()
    main(parsed_args.root_dir, parsed_args.submodules_title)
