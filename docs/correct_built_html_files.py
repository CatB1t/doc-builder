import os
import json
from typing import SupportsComplex

this_dir = os.path.dirname(os.path.realpath(__file__))
with open(os.path.join(this_dir, 'permitted_namespaces.json'), 'r') as file:
    PERMITTED_NAMESPACES = json.loads(file.read())


def trim_namespace(full_namespace):
    for namespace_to_check, permitted_namespace in PERMITTED_NAMESPACES.items():
        if namespace_to_check in full_namespace:
            return permitted_namespace
    return full_namespace


def modify_html_file(html_filepath):
    # Read markup generated by sphinx
    with open(html_filepath) as file:
        html_contents = file.read()
    
    support_index = html_contents.find('<div class="line"><strong>Supported Frameworks:</strong></div>')
    if support_index != -1:
        p_index = html_contents[support_index:].find('<p') + support_index + 2
        html_contents = html_contents[0:p_index] + " class=supported_frameworks" + html_contents[p_index:]
        p_end_index = html_contents[support_index:].find('</p>') + support_index
        a_indices = [ind+18 for ind in range(p_index, p_end_index) if html_contents[ind:ind+18] == 'reference external']
        res = 0
        for a_index in a_indices:
            a_index += res
            html_contents = html_contents[0:a_index] + " logo" + html_contents[a_index:]
            res += 5
    
    # Removing images of the form 1.png, 3.png, etc.
    html_contents = ''.join([char for i, char in enumerate(html_contents)
                             if not (char.isdigit() and html_contents[i+1:i+5] == '.png')])

    # Replace 3.14 with pi
    html_contents = html_contents.replace('3.141592653589793', 'Ï€')

    # Remove # noqa from all files
    # This gets added to the markup in cases of hyperlinks where the line size gets too long
    html_contents = html_contents.replace('# noqa', '')

    # Read all ivy modules for which markup is generated
    with open(os.path.join(this_dir, 'ivy_modules.txt'), 'r') as f:
        module_names = [line.replace('\n', '') for line in f.readlines()]

    # For every module, update path of its reference in current file
    for module_name in module_names:
        html_contents = html_contents.replace(
            'docs/{}.html'.format(module_name), '../{}"'.format(module_name.split('_')[-1]))

    # Update namespaces for inline code in documentation
    contents_split1 = html_contents.split('<span class="sig-prename descclassname">')
    contents_split2 = [item.split('</span>') for item in contents_split1]
    contents_split2_modded = [contents_split2[0]] +\
                             [[trim_namespace(item[0])] + item[1:] for item in contents_split2[1:]]
    contents_split1_modded = ['</span>'.join(item) for item in contents_split2_modded]
    html_contents_modded = '<span class="sig-prename descclassname">'.join(contents_split1_modded)

    # Update links to remove "<no title>" from submodules to be stepped
    breadcrumbs_index = html_contents_modded.find('wy-breadcrumbs')
    no_title_index = html_contents_modded[breadcrumbs_index:].find('&lt;no title&gt;')
    if no_title_index != -1:
        start_index = html_contents_modded[0:breadcrumbs_index + no_title_index].rfind('<li>')
        end_index = html_contents_modded[start_index:].find('</li>')
        html_contents_modded = html_contents_modded.replace(html_contents_modded[start_index:start_index+end_index+6], "")
        no_title_index = html_contents_modded[breadcrumbs_index:].find('&lt;no title&gt;')

    with open(html_filepath, 'w') as file:
        file.write(html_contents_modded)


def modify_html_files(directory):
    # List all files and folders in the build directory
    items_in_dir = os.listdir(directory)
    
    # Get paths of each file in the build directory
    paths = [os.path.join(directory, item) for item in items_in_dir]

    # Recursively traverse all files
    for item in paths:
        if item[-5:] == '.html':
            modify_html_file(item)
        elif os.path.isdir(item):
            modify_html_files(item)


# All html files have been already developed with sphinx build, this script is aimed at modifications to those files.
modify_html_files('build')
print('\nParsed and corrected built html files\n')
